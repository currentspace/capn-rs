{"version":3,"sources":["../../src/capnweb/websocket-transport.ts"],"names":["resolve"],"mappings":";;;;AAUO,MAAM,kBAAA,CAAwC;AAAA,EAQnD,WAAA,CACU,KACR,MAAA,EACA;AAFQ,IAAA,IAAA,CAAA,GAAA,GAAA,GAAA;AAGR,IAAA,IAAA,CAAK,SAAS,MAAA,IAAU,OAAA;AAAA,EAC1B;AAAA,EAvBF;AAUqD,IAAA,MAAA,CAAA,IAAA,EAAA,oBAAA,CAAA;AAAA;AAAA,EAC3C,EAAA,GAAuB,IAAA;AAAA,EACvB,eAA0B,EAAC;AAAA,EAC3B,gBAA2B,EAAC;AAAA,EAC5B,eAAyD,EAAC;AAAA,EAC1D,WAAA,GAAc,KAAA;AAAA,EACd,MAAA;AAAA,EASR,MAAM,OAAA,GAAyB;AAC7B,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;AACtC,MAAA,IAAA,CAAK,EAAA,GAAK,IAAI,SAAA,CAAU,IAAA,CAAK,GAAG,CAAA;AAEhC,MAAA,IAAA,CAAK,EAAA,CAAG,EAAA,CAAG,MAAA,EAAQ,MAAM;AACvB,QAAA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,uBAAA,EAA0B,IAAA,CAAK,GAAG,CAAA,CAAE,CAAA;AACrD,QAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AACnB,QAAA,OAAA,EAAQ;AAGR,QAAA,OAAO,IAAA,CAAK,YAAA,CAAa,MAAA,GAAS,CAAA,EAAG;AACnC,UAAA,MAAM,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,KAAA,EAAM;AACxC,UAAA,IAAA,CAAK,YAAY,OAAO,CAAA;AAAA,QAC1B;AAAA,MACF,CAAC,CAAA;AAED,MAAA,IAAA,CAAK,EAAA,CAAG,EAAA,CAAG,SAAA,EAAW,CAAC,IAAA,KAAS;AAC9B,QAAA,IAAI;AACF,UAAA,MAAM,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,UAAU,CAAA;AAC1C,UAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,mBAAA,EAAqB,OAAO,CAAA;AAG9C,UAAA,IAAI,IAAA,CAAK,YAAA,CAAa,MAAA,GAAS,CAAA,EAAG;AAChC,YAAA,MAAMA,QAAAA,GAAU,IAAA,CAAK,YAAA,CAAa,KAAA,EAAM;AACxC,YAAAA,SAAQ,OAAO,CAAA;AAAA,UACjB,CAAA,MAAO;AACL,YAAA,IAAA,CAAK,aAAA,CAAc,KAAK,OAAO,CAAA;AAAA,UACjC;AAAA,QACF,SAAS,KAAA,EAAO;AACd,UAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,0BAAA,EAA4B,KAAK,CAAA;AAAA,QACrD;AAAA,MACF,CAAC,CAAA;AAED,MAAA,IAAA,CAAK,EAAA,CAAG,EAAA,CAAG,OAAA,EAAS,CAAC,MAAM,MAAA,KAAW;AACpC,QAAA,IAAA,CAAK,OAAO,IAAA,CAAK,CAAA,kBAAA,EAAqB,IAAI,CAAA,CAAA,EAAI,MAAM,CAAA,CAAE,CAAA;AACtD,QAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAGnB,QAAA,OAAO,IAAA,CAAK,YAAA,CAAa,MAAA,GAAS,CAAA,EAAG;AACnC,UAAA,MAAMA,QAAAA,GAAU,IAAA,CAAK,YAAA,CAAa,KAAA,EAAM;AACxC,UAAAA,SAAQ,IAAI,CAAA;AAAA,QACd;AAAA,MACF,CAAC,CAAA;AAED,MAAA,IAAA,CAAK,EAAA,CAAG,EAAA,CAAG,OAAA,EAAS,CAAC,KAAA,KAAU;AAC7B,QAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,kBAAA,EAAoB,KAAK,CAAA;AAC3C,QAAA,MAAA,CAAO,KAAK,CAAA;AAAA,MACd,CAAC,CAAA;AAGD,MAAA,UAAA,CAAW,MAAM;AACf,QAAA,IAAI,CAAC,KAAK,WAAA,EAAa;AACrB,UAAA,MAAA,CAAO,IAAI,KAAA,CAAM,8BAA8B,CAAC,CAAA;AAAA,QAClD;AAAA,MACF,GAAG,GAAK,CAAA;AAAA,IACV,CAAC,CAAA;AAAA,EACH;AAAA,EAEA,MAAM,KAAK,OAAA,EAAiC;AAC1C,IAAA,IAAI,CAAC,IAAA,CAAK,WAAA,IAAe,CAAC,KAAK,EAAA,EAAI;AACjC,MAAA,IAAA,CAAK,YAAA,CAAa,KAAK,OAAO,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,YAAY,OAAO,CAAA;AAAA,EAC1B;AAAA,EAEQ,YAAY,OAAA,EAAwB;AAC1C,IAAA,IAAI,CAAC,IAAA,CAAK,EAAA,IAAM,KAAK,EAAA,CAAG,UAAA,KAAe,UAAU,IAAA,EAAM;AACrD,MAAA,IAAA,CAAK,YAAA,CAAa,KAAK,OAAO,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,IAAI;AACF,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,SAAA,CAAU,OAAO,CAAA;AACnC,MAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,kBAAA,EAAoB,OAAO,CAAA;AAC7C,MAAA,IAAA,CAAK,EAAA,CAAG,KAAK,IAAI,CAAA;AAAA,IACnB,SAAS,KAAA,EAAO;AACd,MAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,yBAAA,EAA2B,KAAK,CAAA;AAClD,MAAA,MAAM,KAAA;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,OAAA,GAAmC;AAEvC,IAAA,IAAI,IAAA,CAAK,aAAA,CAAc,MAAA,GAAS,CAAA,EAAG;AACjC,MAAA,OAAO,IAAA,CAAK,cAAc,KAAA,EAAM;AAAA,IAClC;AAGA,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC9B,MAAA,IAAA,CAAK,YAAA,CAAa,KAAK,OAAO,CAAA;AAG9B,MAAA,UAAA,CAAW,MAAM;AACf,QAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ,OAAO,CAAA;AAC/C,QAAA,IAAI,UAAU,EAAA,EAAI;AAChB,UAAA,IAAA,CAAK,YAAA,CAAa,MAAA,CAAO,KAAA,EAAO,CAAC,CAAA;AACjC,UAAA,OAAA,CAAQ,IAAI,CAAA;AAAA,QACd;AAAA,MACF,GAAG,GAAK,CAAA;AAAA,IACV,CAAC,CAAA;AAAA,EACH;AAAA,EAEA,MAAM,KAAA,GAAuB;AAC3B,IAAA,IAAI,KAAK,EAAA,EAAI;AACX,MAAA,IAAA,CAAK,GAAG,KAAA,EAAM;AACd,MAAA,IAAA,CAAK,EAAA,GAAK,IAAA;AAAA,IACZ;AACA,IAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAAA,EACrB;AACF;AAEO,MAAM,kBAAA,CAAwC;AAAA,EAInD,WAAA,CACU,KACR,MAAA,EACA;AAFQ,IAAA,IAAA,CAAA,GAAA,GAAA,GAAA;AAGR,IAAA,IAAA,CAAK,SAAS,MAAA,IAAU,OAAA;AAAA,EAC1B;AAAA,EAnJF;AA0IqD,IAAA,MAAA,CAAA,IAAA,EAAA,oBAAA,CAAA;AAAA;AAAA,EAC3C,eAA0B,EAAC;AAAA,EAC3B,MAAA;AAAA,EASR,MAAM,KAAK,OAAA,EAAiC;AAC1C,IAAA,IAAA,CAAK,YAAA,CAAa,KAAK,OAAO,CAAA;AAAA,EAChC;AAAA,EAEA,MAAM,OAAA,GAAmC;AAEvC,IAAA,IAAI,IAAA,CAAK,YAAA,CAAa,MAAA,KAAW,CAAA,EAAG;AAClC,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,IAAI;AACF,MAAA,MAAM,QAAA,GAAW,CAAC,GAAG,IAAA,CAAK,YAAY,CAAA;AACtC,MAAA,IAAA,CAAK,aAAa,MAAA,GAAS,CAAA;AAE3B,MAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,wBAAA,EAA0B,QAAQ,CAAA;AAEpD,MAAA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,IAAA,CAAK,GAAA,EAAK;AAAA,QACrC,MAAA,EAAQ,MAAA;AAAA,QACR,OAAA,EAAS;AAAA,UACP,cAAA,EAAgB;AAAA,SAClB;AAAA,QACA,IAAA,EAAM,IAAA,CAAK,SAAA,CAAU,QAAQ;AAAA,OAC9B,CAAA;AAED,MAAA,IAAI,CAAC,SAAS,EAAA,EAAI;AAChB,QAAA,MAAM,IAAI,MAAM,CAAA,KAAA,EAAQ,QAAA,CAAS,MAAM,CAAA,EAAA,EAAK,QAAA,CAAS,UAAU,CAAA,CAAE,CAAA;AAAA,MACnE;AAEA,MAAA,MAAM,OAAA,GAAU,MAAM,QAAA,CAAS,IAAA,EAAK;AACpC,MAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,0BAAA,EAA4B,OAAO,CAAA;AAIrD,MAAA,OAAO,OAAA,CAAQ,CAAC,CAAA,IAAK,IAAA;AAAA,IACvB,SAAS,KAAA,EAAO;AACd,MAAA,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,4BAAA,EAA8B,KAAK,CAAA;AACrD,MAAA,MAAM,KAAA;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,KAAA,GAAuB;AAAA,EAE7B;AACF","file":"websocket-transport.js","sourcesContent":["/**\n * WebSocket Transport Implementation\n *\n * Implements the Transport interface for WebSocket communication\n * with the Rust Cap'n Web server.\n */\n\nimport WebSocket from 'ws'\nimport type { Transport, Message, Logger } from './types.js'\n\nexport class WebSocketTransport implements Transport {\n  private ws: WebSocket | null = null\n  private messageQueue: Message[] = []\n  private responseQueue: Message[] = []\n  private resolveQueue: Array<(message: Message | null) => void> = []\n  private isConnected = false\n  private logger: Logger\n\n  constructor(\n    private url: string,\n    logger?: Logger\n  ) {\n    this.logger = logger || console\n  }\n\n  async connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(this.url)\n\n      this.ws.on('open', () => {\n        this.logger.info(`WebSocket connected to ${this.url}`)\n        this.isConnected = true\n        resolve()\n\n        // Send queued messages\n        while (this.messageQueue.length > 0) {\n          const message = this.messageQueue.shift()!\n          this.sendMessage(message)\n        }\n      })\n\n      this.ws.on('message', (data) => {\n        try {\n          const message = JSON.parse(data.toString()) as Message\n          this.logger.debug('Received message:', message)\n\n          // Handle queued receive requests\n          if (this.resolveQueue.length > 0) {\n            const resolve = this.resolveQueue.shift()!\n            resolve(message)\n          } else {\n            this.responseQueue.push(message)\n          }\n        } catch (error) {\n          this.logger.error('Failed to parse message:', error)\n        }\n      })\n\n      this.ws.on('close', (code, reason) => {\n        this.logger.info(`WebSocket closed: ${code} ${reason}`)\n        this.isConnected = false\n\n        // Resolve pending receives with null\n        while (this.resolveQueue.length > 0) {\n          const resolve = this.resolveQueue.shift()!\n          resolve(null)\n        }\n      })\n\n      this.ws.on('error', (error) => {\n        this.logger.error('WebSocket error:', error)\n        reject(error)\n      })\n\n      // Connection timeout\n      setTimeout(() => {\n        if (!this.isConnected) {\n          reject(new Error('WebSocket connection timeout'))\n        }\n      }, 10000)\n    })\n  }\n\n  async send(message: Message): Promise<void> {\n    if (!this.isConnected || !this.ws) {\n      this.messageQueue.push(message)\n      return\n    }\n\n    this.sendMessage(message)\n  }\n\n  private sendMessage(message: Message): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      this.messageQueue.push(message)\n      return\n    }\n\n    try {\n      const json = JSON.stringify(message)\n      this.logger.debug('Sending message:', message)\n      this.ws.send(json)\n    } catch (error) {\n      this.logger.error('Failed to send message:', error)\n      throw error\n    }\n  }\n\n  async receive(): Promise<Message | null> {\n    // Return queued response if available\n    if (this.responseQueue.length > 0) {\n      return this.responseQueue.shift()!\n    }\n\n    // Wait for next message\n    return new Promise((resolve) => {\n      this.resolveQueue.push(resolve)\n\n      // Timeout after 30 seconds\n      setTimeout(() => {\n        const index = this.resolveQueue.indexOf(resolve)\n        if (index !== -1) {\n          this.resolveQueue.splice(index, 1)\n          resolve(null)\n        }\n      }, 30000)\n    })\n  }\n\n  async close(): Promise<void> {\n    if (this.ws) {\n      this.ws.close()\n      this.ws = null\n    }\n    this.isConnected = false\n  }\n}\n\nexport class HttpBatchTransport implements Transport {\n  private messageQueue: Message[] = []\n  private logger: Logger\n\n  constructor(\n    private url: string,\n    logger?: Logger\n  ) {\n    this.logger = logger || console\n  }\n\n  async send(message: Message): Promise<void> {\n    this.messageQueue.push(message)\n  }\n\n  async receive(): Promise<Message | null> {\n    // HTTP batch transport sends all messages at once and receives responses\n    if (this.messageQueue.length === 0) {\n      return null\n    }\n\n    try {\n      const messages = [...this.messageQueue]\n      this.messageQueue.length = 0\n\n      this.logger.debug('Sending batch request:', messages)\n\n      const response = await fetch(this.url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(messages),\n      })\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n\n      const results = await response.json() as Message[]\n      this.logger.debug('Received batch response:', results)\n\n      // For simplicity, return the first result\n      // In a real implementation, you'd need to handle multiple responses\n      return results[0] || null\n    } catch (error) {\n      this.logger.error('HTTP batch request failed:', error)\n      throw error\n    }\n  }\n\n  async close(): Promise<void> {\n    // Nothing to close for HTTP transport\n  }\n}"]}