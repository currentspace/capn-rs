{"version":3,"sources":["../src/tier2-websocket-tests.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { newWebSocketRpcSession } from 'capnweb';\n\n/**\n * TIER 2 WebSocket: Stateful Session Management Tests over WebSocket\n *\n * Goal: Verify session persistence and state tracking over WebSocket transport\n * Tests: Same as tier2-stateful-sessions.ts but using WebSocket instead of HTTP batch\n * Success Criteria: State persists across WebSocket messages, proper resource management\n *\n * Prerequisites: Tier 1 tests must pass (basic protocol compliance)\n */\n\ninterface StatefulCalculator {\n    add(a: number, b: number): Promise<number>;\n    multiply(a: number, b: number): Promise<number>;\n    divide(a: number, b: number): Promise<number>;\n    subtract(a: number, b: number): Promise<number>;\n}\n\nconst port = process.argv[2] || '9000';\nconst wsEndpoint = `ws://localhost:${port}/rpc/ws`;\n\nclass Tier2WebSocketTests {\n    private passed = 0;\n    private total = 0;\n\n    private async test(name: string, testFn: () => Promise<boolean>): Promise<void> {\n        this.total++;\n        console.log(`\\nüß™ Test ${this.total}: ${name} (WebSocket)`);\n        console.log('‚îÄ'.repeat(70));\n\n        try {\n            const result = await testFn();\n            if (result) {\n                this.passed++;\n                console.log('‚úÖ PASSED');\n            } else {\n                console.log('‚ùå FAILED');\n            }\n        } catch (error: any) {\n            console.log(`‚ùå FAILED: ${error.message}`);\n        }\n    }\n\n    private async sessionPersistence(): Promise<boolean> {\n        console.log('Testing WebSocket session persistence across multiple messages...');\n\n        try {\n            const session = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n\n            // Make multiple calls that should be processed by the same WebSocket connection\n            const results: number[] = [];\n\n            console.log('Making sequential requests over WebSocket...');\n            results.push(await session.add(1, 2));\n            results.push(await session.multiply(3, 4));\n            results.push(await session.subtract(10, 5));\n\n            console.log(`Results: ${results.join(', ')}`);\n\n            // Close the session properly\n            if ('close' in session) {\n                (session as any).close();\n            }\n\n            // Check if we got consistent numeric responses\n            const allNumbers = results.every(r => typeof r === 'number' && !isNaN(r));\n            const correctValues = results[0] === 3 && results[1] === 12 && results[2] === 5;\n\n            if (allNumbers && correctValues) {\n                console.log('‚úì All operations returned correct results');\n                console.log('‚úì WebSocket session maintained state across multiple messages');\n                return true;\n            } else if (allNumbers) {\n                console.log('‚úì WebSocket session persistent (wrong values may indicate calculation issues)');\n                console.log(`  Expected: [3, 12, 5], Got: [${results.join(', ')}]`);\n                return false;\n            } else {\n                console.log('‚úó Inconsistent response types or WebSocket session issues');\n                return false;\n            }\n        } catch (error: any) {\n            console.log(`WebSocket session persistence test failed: ${error.message}`);\n            return false;\n        }\n    }\n\n    private async sessionIsolation(): Promise<boolean> {\n        console.log('Testing WebSocket session isolation between different connections...');\n\n        try {\n            // Create two separate WebSocket sessions\n            const session1 = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n            const session2 = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n\n            console.log('Creating two separate WebSocket client sessions...');\n\n            // Make different calls from each session\n            const [result1, result2] = await Promise.all([\n                session1.add(5, 5),\n                session2.multiply(6, 6)\n            ]);\n\n            console.log(`WebSocket Session 1 result: ${result1}`);\n            console.log(`WebSocket Session 2 result: ${result2}`);\n\n            // Close sessions properly\n            if ('close' in session1) (session1 as any).close();\n            if ('close' in session2) (session2 as any).close();\n\n            // Both should work independently\n            if (typeof result1 === 'number' && typeof result2 === 'number') {\n                if (result1 === 10 && result2 === 36) {\n                    console.log('‚úì Both WebSocket sessions returned correct results');\n                    console.log('‚úì WebSocket sessions are properly isolated');\n                    return true;\n                } else {\n                    console.log('‚úì WebSocket sessions isolated but calculation errors');\n                    console.log(`  Expected: [10, 36], Got: [${result1}, ${result2}]`);\n                    return false;\n                }\n            } else {\n                console.log('‚úó One or both WebSocket sessions failed to respond properly');\n                return false;\n            }\n        } catch (error: any) {\n            console.log(`WebSocket session isolation test failed: ${error.message}`);\n            return false;\n        }\n    }\n\n    private async concurrentOperations(): Promise<boolean> {\n        console.log('Testing concurrent operations within a single WebSocket session...');\n\n        try {\n            const session = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n\n            console.log('Launching concurrent operations over WebSocket...');\n            const startTime = Date.now();\n\n            // Run multiple operations concurrently over the same WebSocket\n            const results = await Promise.all([\n                session.add(2, 3),\n                session.multiply(4, 5),\n                session.divide(20, 4),\n                session.subtract(15, 7)\n            ]);\n\n            const duration = Date.now() - startTime;\n            console.log(`All WebSocket operations completed in ${duration}ms`);\n            console.log(`Results: ${results.join(', ')}`);\n\n            // Close session properly\n            if ('close' in session) (session as any).close();\n\n            // Check results\n            const expected = [5, 20, 5, 8];\n            const allCorrect = results.every((r, i) => r === expected[i]);\n\n            if (allCorrect) {\n                console.log('‚úì All concurrent WebSocket operations returned correct results');\n                console.log('‚úì Server handled concurrent WebSocket requests properly');\n\n                // Bonus: Check if operations were actually concurrent\n                if (duration < 1000) {\n                    console.log('‚úì WebSocket operations appear to be processed concurrently');\n                }\n\n                return true;\n            } else {\n                console.log('‚úì Concurrent WebSocket operations completed but with incorrect results');\n                console.log(`  Expected: [${expected.join(', ')}], Got: [${results.join(', ')}]`);\n                return false;\n            }\n        } catch (error: any) {\n            console.log(`Concurrent WebSocket operations test failed: ${error.message}`);\n            return false;\n        }\n    }\n\n    private async errorRecovery(): Promise<boolean> {\n        console.log('Testing error recovery and WebSocket session stability...');\n\n        try {\n            const session = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n\n            // First, perform a successful operation\n            console.log('Performing initial successful operation over WebSocket...');\n            const initial = await session.add(1, 1);\n            console.log(`Initial result: ${initial}`);\n\n            if (typeof initial !== 'number' || initial !== 2) {\n                console.log('‚úó Initial WebSocket operation failed - cannot test error recovery');\n                if ('close' in session) (session as any).close();\n                return false;\n            }\n\n            // Then, trigger an error\n            console.log('Triggering an error (division by zero) over WebSocket...');\n            let errorOccurred = false;\n            try {\n                await session.divide(5, 0);\n                console.log('‚ÑπÔ∏è  Division by zero did not throw error (unexpected)');\n            } catch (error: any) {\n                console.log(`‚úì Error properly thrown over WebSocket: ${error.message}`);\n                errorOccurred = true;\n            }\n\n            // Finally, verify WebSocket session is still functional\n            console.log('Testing WebSocket session recovery with another operation...');\n            const recovery = await session.multiply(3, 4);\n            console.log(`Recovery result: ${recovery}`);\n\n            // Close session properly\n            if ('close' in session) (session as any).close();\n\n            if (typeof recovery === 'number' && recovery === 12) {\n                console.log('‚úì WebSocket session recovered after error');\n                console.log('‚úì Error handling did not corrupt WebSocket session state');\n                return true;\n            } else {\n                console.log('‚úó WebSocket session corrupted after error');\n                return false;\n            }\n        } catch (error: any) {\n            console.log(`WebSocket error recovery test failed: ${error.message}`);\n            return false;\n        }\n    }\n\n    private async realTimeMessaging(): Promise<boolean> {\n        console.log('Testing real-time bidirectional messaging over WebSocket...');\n\n        try {\n            const session = newWebSocketRpcSession<StatefulCalculator>(wsEndpoint);\n\n            console.log('Testing rapid-fire operations over persistent WebSocket connection...');\n            const startTime = Date.now();\n\n            // Send rapid sequence of operations to test real-time capabilities\n            const operations = [];\n            for (let i = 0; i < 10; i++) {\n                operations.push(session.add(i, i + 1));\n            }\n\n            const results = await Promise.all(operations);\n            const duration = Date.now() - startTime;\n\n            console.log(`10 rapid WebSocket operations completed in ${duration}ms`);\n            console.log(`Average per operation: ${(duration / 10).toFixed(1)}ms`);\n\n            // Close session properly\n            if ('close' in session) (session as any).close();\n\n            // Check results (should be [1, 3, 5, 7, 9, 11, 13, 15, 17, 19])\n            const expected = Array.from({length: 10}, (_, i) => i + (i + 1));\n            const allCorrect = results.every((r, i) => r === expected[i]);\n\n            if (allCorrect) {\n                console.log('‚úì All rapid-fire WebSocket operations returned correct results');\n                console.log('‚úì WebSocket demonstrates real-time messaging capability');\n\n                if (duration < 500) {\n                    console.log('‚úì Excellent WebSocket performance for real-time use');\n                }\n\n                return true;\n            } else {\n                console.log('‚úó Some rapid-fire WebSocket operations returned incorrect results');\n                console.log(`  Expected: [${expected.join(', ')}]`);\n                console.log(`  Got: [${results.join(', ')}]`);\n                return false;\n            }\n        } catch (error: any) {\n            console.log(`Real-time WebSocket messaging test failed: ${error.message}`);\n            return false;\n        }\n    }\n\n    async run(): Promise<void> {\n        console.log('üåê TIER 2 WebSocket: Stateful Session Management Tests');\n        console.log('====================================================');\n        console.log(`üìç Testing WebSocket endpoint: ${wsEndpoint}`);\n        console.log('üéØ Goal: Verify session persistence over WebSocket transport');\n        console.log('üìã Prerequisites: Tier 1 tests must pass + WebSocket support');\n        console.log('');\n\n        // Test 1: WebSocket session persistence\n        await this.test('WebSocket Session Persistence', () => this.sessionPersistence());\n\n        // Test 2: WebSocket session isolation\n        await this.test('WebSocket Session Isolation', () => this.sessionIsolation());\n\n        // Test 3: Concurrent operations over WebSocket\n        await this.test('Concurrent WebSocket Operations', () => this.concurrentOperations());\n\n        // Test 4: Error recovery over WebSocket\n        await this.test('WebSocket Error Recovery', () => this.errorRecovery());\n\n        // Test 5: Real-time messaging (WebSocket-specific)\n        await this.test('Real-time Bidirectional Messaging', () => this.realTimeMessaging());\n\n        // Results\n        console.log('\\n' + '='.repeat(70));\n        console.log('üåê TIER 2 WebSocket RESULTS');\n        console.log('='.repeat(70));\n\n        const passRate = Math.round((this.passed / this.total) * 100);\n        console.log(`‚úÖ Passed: ${this.passed}/${this.total} (${passRate}%)`);\n\n        if (this.passed === this.total) {\n            console.log('üéâ TIER 2 WebSocket COMPLETE: WebSocket stateful session management working!');\n            console.log('üöÄ WebSocket transport provides real-time capabilities');\n            console.log('üìà Ready for Tier 3: Complex Application Logic over WebSocket');\n            process.exit(0);\n        } else if (this.passed >= this.total * 0.6) {\n            console.log('‚ö†Ô∏è  TIER 2 WebSocket PARTIAL: Some WebSocket session management issues remain');\n            console.log('üîß Address WebSocket state issues before Tier 3');\n            process.exit(1);\n        } else {\n            console.log('üí• TIER 2 WebSocket FAILED: WebSocket session management not working');\n            console.log('üö® Fix WebSocket state tracking before proceeding');\n            process.exit(2);\n        }\n    }\n}\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(3);\n});\n\n// Run tests\nconst tier2WebSocket = new Tier2WebSocketTests();\ntier2WebSocket.run();"],"mappings":"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","names":[]}